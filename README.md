# c_language
## 참고 교재
- KERNIGHAN의 C언어 프로그래밍

<details>
<summary>1장 정리</summary>

- 파일의 끝을 나타내는 기호는 -1 또는 0 이다.
- = 보다 !=의 우선순위가 높다.
- putchar()해당 정수값에 해당하는 아스키값을 출력한다.
- 이 책에서 call-by-reference, call-by-value
  - call-by-reference : 변수명을 매개변수로 넘겨줌
  - call-by-value : 값을 매개변수로 넘겨줌
- extern 자료형 변수명 : 다른 파일(또는 다른 위치)에 정의된 전역 변수나 함수가 있다고 선언만 해주는 키워드.
</details>

<details>
<summary>2장 정리</summary>

- 변수명이 밑줄로 시작하지 못하는 이유 -> 라이브러리 이름이 밑줄로 시작하는 경우가 있어서
- long double : 이 한정사는 부동소수형의 정밀도를 더 높여준다.
- 문자열 상수는 컴파일 시에 연결될 수 있다.
- 열거 상수 : 정수형 상수의 나열
  - 상수의 이름은 모두 달라야 하지만 값은 같을 수 있다.
- 열겨형 변수의 값을 확인하기 위해서는 디버거를 사용해야 한다.
- const : 원소들의 값이 변하지 않는다.

### 산술 연산자
- float, double는 %연산자가 적용될 수 없다.

### 형 변환
- 자동변환은 정보의 손실 없이 변환 가능할 때뿐이다.
- EBCDIC : IBM에서 만들고 1960년대 메인 프레임 컴퓨터인 System/360 시리즈에서 사용한 인코딩 방식
  - 8비트
  - 문자값이 불연속적이다.
- 기계의 표준 출력문자 세트의 어떤 글자도 음수가 되지 않는다. -> 기기에 따라서 다르다.
- float는 자동적으로 double로 변환되지 않는다.
- double이 float로 변환될 때 소수 이하를 버릴지 반올림할지는 기종에 따라 다르다.
- cast
- 함수원형 : 함수가 어떤 인자를 받고, 어떤 타입을 반환하는지를 미리 선언하는것
- getchar에서는 EOF를 구분하기 위해서 int로 반환값을 받는다.

### 증가 연산자 감소 연산자
- 변수에만 사용될 수 있고, 수식에는 사용할 수 없다.

### 비트 연산자
- 비트를 사용하는 부분이 많이 약했던거 같다.

### 지정 연산자와 수식
- *= 은 + 보다 우선순위가 낮다
- unsigned로 매개변수를 선언함으로써 우측 이동 시 빈 비트가 기계에 관계없이 sign 비트가 아닌 0으로 채워질 수 있다.
- 컴파일러가 보다 효율적인 코드를 생성하는데 도움이 된다.
  - x값이 레지스터에 이미 올라가 있는 상태에서 바로 덧셈이 가능하다.
  - 별로 메모리 접근 없이 연산 수행이 가능
  - x = x + y => x+y결과를 메모리의 한 공간에 저장한 이후에 x에 대입한다.
- x &= (x-1)을 사용하면 최우측의 비트를 지우는게 가능하다.
  - 왜냐하면 x-1을 수행하면 최우측의 1비트는 0이 나오고 그 아래는 전부 1이 나온다. 
  - 여기서 & 연산을 수행하면 최우측의 비트 부분에 0을 AND연산 하기 때문에 0으로 변경된다.
  - 그 이하의 자리에는 원래의 수가 0이기 때문에 AND연산하면 다 0으로 바뀐다.

#### 계산순서에 의존하는 프로그램을 작성하는 것은 어떤 언어에서든 나쁜 프로그래밍 습관이다.
</details>

<details>
<summary>3장 제어 흐름</summary>

- 함수 인자에서의 콤마나 선언문에서 변수를 구별하는 콤마는 연산자가 아니므로 왼쪽에서 오른쪽으로의 연산을 보장하지 않는다.
- goto문은 중첩된 루프에서 한 번에 모든 루프를 벗어날 때 유용하다.
- goto문을 사용하면 구조가 복잡해지기 때문에 사용하지 않는게 좋다.
</details>